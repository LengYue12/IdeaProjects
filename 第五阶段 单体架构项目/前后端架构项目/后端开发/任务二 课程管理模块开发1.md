# 任务二 课程管理模块开发1  学习笔记

# 1. 开发流程

## 1.1 进行课程管理模块功能的需求分析

* **查询课程列表信息的功能**
* **多条件查询课程信息的功能**
* **新建课程营销信息的功能**
* **修改课程营销信息的功能**
* **修改课程状态的功能**



## 1.2 数据库表分析

不需要用的字段排除掉。

在课程展示页面需要用到5个字段，其他字段信息在营销信息



## 1.3 根据需要用到的字段信息进行实体类设计

根据数据库中的Course表，对应创建Course.java 实体类



## 1.4 课程模块 Dao层接口及实现类编写

CourseDAO与CourseDAOImpl类

## 1.5 课程模块 Service层接口及实现类编写

CourseService与CourseServiceImpl类

## 1.6 Web层的CourseServlet编写

```
在当前Servlet中只写业务相关的代码，具体的请求处理交给BaseServlet调度
```

CourseServlet 要继承通用的BaseServlet



# 2. 接口1：查询课程列表信息

## 2.1 需求分析		**其实就是查询操作**

页面分析，需要展示哪些数据			

展示课程相关的数据，向页面返回的字段有：			**字段来自Course表**

* ID （id）
* 课程名称(course_name)
* 价格(price)
* 排序(sort_num)
* 状态(status  0是下架，1是上架)

## 2.2 编写代码

### 2.2.1 **DAO层编写**

1）在CourseDao里添加一个**findCourseList方法**

**每一条要展示的数据就是一个Course对象，所以返回List集合**

```java
接口 CourseDao
    // 查询课程列表信息的方法
    public List<Course> findCourseList();

实现类 CourseDaoImpl
     @Override
    public List<Course> findCourseList() {

        try {
            // 1.使用DBUtils操作数据库
            // 创建QueryRunner对象，传入数据库连接池
            QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

            // 2.编写SQL  判断是否删除  取出is_del = 0 的数据，未删除的数据
            String sql = "SELECT \n" +
                    "id,\n" +
                    "course_name,\n" +
                    "price,\n" +
                    "sort_num,\n" +
                    "STATUS\n" +
                    "FROM course WHERE is_del = ?";

            // 3.执行查询
            List<Course> courseList = qr.query(sql, new BeanListHandler<Course>(Course.class), 0);

            return courseList;
        } catch (SQLException e) {
            e.printStackTrace();
            
            // 若出现异常返回null
            return null;
        }
    }
```

**逻辑删除**

* 逻辑删除本质是**修改操作**，所谓的逻辑删除并不是真正的删除数据。就算用户把数据删掉，我们在数据库中只是做一个标识，而不是真正的删除掉。0代表未删除，1代表删除  			**所以查询课程列表信息就是查询出0的数据**

**物理删除**

* 物理删除是真正的从数据库中作删除操作

### 2.2.2 **Service层编写**

在CourseService层添加**findCourseList方法**

```java
接口 CourseService
    // 创建一个查询课程列表页面的方法
    public List<Course> findCourseList();
实现类 CourseServiceImpl
    // 创建CourseDao对象
    CourseDao courseDao = new CourseDaoImpl();

    @Override
    public List<Course> findCourseList() {

        List<Course> courseList = courseDao.findCourseList();
        return courseList;
    }
    
```

### 2.2.3 **Servlet编写**

#### 2.2.3.1 接口开发规范

​	我们在做的是一个前后端分离项目，需要通过接口文档对接的项目。**前端和后端都是依照接口文档进行开发的。所以接口文档中必须要定义一定的规范**。所以开发过程中要仔细查看前端所需的api接口和参数字段

**严格按照接口文档的开发规范进行开发，提高效率，对请求及响应格式进行规范化。**

| 开发规范                                                     |
| ------------------------------------------------------------ |
| 1. get请求时，采用key/value的格式，Servlet中可以使用 getParameter()获取。 |
| 2. post请求时有三种数据格式<br>第一种：Json数据格式，Servlet中可以使用fastJson进行解析<br>第二种：提交的表单数据<br>第三种：文件等多部件类型(multipart/form-data)文件上传操作时 |
| 3.服务端响应结果统一为json                                   |

JSON的数据格式比较简单，易于读写，可以简化服务端和客户端的代码开发量，所以使用JSON进行数据响应

使用JSON解析工具为fastJson，在pom.xml中引入依赖

#### 2.2.3.2 接口文档

​	前后端人员根据接口文档并行开发，按照接口文档的规定进行后端开发

#### 2.2.3.3 编写CourseServlet

阅读完接口文档后编写查询课程列表信息的功能

在CourseServlet中添加**findCourseList方法**

```java
/**
 * 在当前Servlet中只写业务相关的代码，具体的请求处理交给BaseServlet调度
 */
@WebServlet("/course")
public class CourseServlet extends BaseServlet {

    // 查询课程信息列表的功能
    public void findCourseList(HttpServletRequest request, HttpServletResponse response){

        try {
            // 1.接收参数
            // 在BaseServlet里已完成

            // 2.业务处理
            CourseService courseService = new CourseServiceImpl();
            List<Course> courseList = courseService.findCourseList();

            // 3.进行结果响应，根据接口文档的规范响应结果为JSON，所以将集合转为JSON
            // 使用SimplePropertyPreFilter类 来指定要转换的JSON对象和要转换的JSON字段
            SimplePropertyPreFilter filter = new SimplePropertyPreFilter(Course.class,
                    "id","course_name","price","sort_num","status");

            String result = JSON.toJSONString(courseList,filter);

            response.getWriter().print(result);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

**由于返回的JSON结果有不需要的字段所以可以使用**：

* ```
  SimplePropertyPreFilter对象来指定要转换的JSON对象和要转换的字段
  ```

## 2.3 接口测试工具Postman

### 2.3.1 postman介绍

Postman是一款http接口测试工具，**使用postman可以完成http各种请求的功能测试**

* 要测试的是后台的接口，查询课程列表信息，因为使用的是前后端分离方式进行开发的
* 所以对于后台人员来说，必须要有一个接口测试工具，来模拟前台页面对于后台接口的请求功能的测试

### 2.3.2 Postman使用                      **记录测试过的接口**

1. 新建一个Postman窗口
2. 可以设置请求方式，设置请求携带的参数，发送请求到后端接口

### 2.3.3 使用postman测试接口

1）发送请求到指定的Servlet，发送URL并携带方法名称methodName。返回的是JSON数据

### 2.3.4 创建模块将请求分类

1）创建课程模块，添加名称course和描述 课程管理模块

2）选择Save As 将请求保存到对应的模块中   将上面的URL请求保存到对应的文件夹

3）描述一下请求的相关信息(获取课程列表信息的接口) 并保存到course中

# 3. 接口2：多条件查询课程信息

## 3.1 需求分析

1）根据课程名称和课程状态进行查询

2）要查询的字段有：

```
id，course_name,price,sort_num,status
```

3)查询的条件

```
is_del  逻辑删除，代表查询未删除的数据 0
course_name 模糊查询课程名
status  状态
```

## 3.2 根据条件查询课程信息

### 3.2.2 Dao层编写		

1）注意：用户在查询时，可能只根据状态查询，还可能根据课程名称查询。

所以查询条件不固定，所以要进行判断，如果传了课程名称，就把SQL条件拼上

2）在CourseDao里添加一个**findByCourseNameAndStatus方法**

3）**因为如果使用课程名称进行模糊查询或者根据状态查询的话，查询出的肯定是多条数据，所以返回List**

4）**多条件拼接时，如果所有的查询条件不固定。假设 拼接的SQL中有and并且 本来的SQL中没有and 的话就需要 在原来SQL中拼接where 1=1。否则直接在原来SQL上拼接and就会出错**

```java
// 根据条件查询课程信息
    @Override
    public List<Course> findByCourseNameAndStatus(String course_name, String status) {

        try {
            // 因为查询条件不固定，所以需要对SQL进行拼接
            // 1.创建QueryRunner
            QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

            // 2.编写SQL 当前的查询为多条件不定项查询
            // 2.1 创建StringBuffer对象，将SQL字符串添加进缓冲区
            StringBuffer sb = new StringBuffer("SELECT id,course_name,price,sort_num,STATUS FROM course WHERE 1=1 and is_del = ?");

            // 2.2 创建List集合 保存任意类型的参数
            List<Object> list = new ArrayList<>();
            list.add(0);

            // 2.3 判断传入的参数是否为空，如果course_name有值，就追加SQL
            if (course_name != null && course_name != "") {
                sb.append(" AND course_name LIKE ?");

                // 因为是Like模糊查询，所以修改course_name的值,需要拼接 %
                course_name = "%" + course_name + "%";
                // 将条件放进list集合
                list.add(course_name);
            }

            // 如果status有值，继续在StringBuffer里拼接SQL
            if (status != null && status != "") {
                sb.append("AND STATUS = ?");
                // 将status 转为 int
                int i = Integer.parseInt(status);
                list.add(i);
            }

            // 执行查询操作
            List<Course> courseList = qr.query(sb.toString(), new BeanListHandler<Course>(Course.class), list.toArray());
            return courseList;
        } catch (SQLException e) {
            e.printStackTrace();
            // 出现异常返回null
            return null;
        }
    }
```

### 3.2.3 Service层编写

在CourseService层添加**findByCourseNameAndStatus方法**

### CourseService 接口

	// 根据条件查询课程信息
	
	public List<Course> findByCourseNameAndStatus(String course_name,String status);


CourseServiceImpl实现类

     // 根据条件查询课程信息
    
    @Override
    
    public List<Course> findByCourseNameAndStatus(String course_name, String status) {


         List<Course> courseList = courseDao.findByCourseNameAndStatus(course_name, status);
    
         return courseList;
    
    }

### 3.2.4 Servlet编写

在CourseServlet中添加**findByCourseNameAndStatus方法**

```java
// 根据条件查询课程信息的功能
    public void findByCourseNameAndStatus(HttpServletRequest request, HttpServletResponse response){

        try {
            // 1.接收前台传过来的参数
            String course_name = request.getParameter("course_name");
            String status = request.getParameter("status");

            // 2.调用业务层处理
            CourseService courseService = new CourseServiceImpl();
            List<Course> courseList = courseService.findByCourseNameAndStatus(course_name, status);

            // 3.返回JSON结果 SimplePropertyPreFilter进行JSON数据的过滤，因为有些字段不需要
            SimplePropertyPreFilter filter = new SimplePropertyPreFilter(Course.class,"id",
                    "course_name","price","sort_num","status");

            // 4.将获取到的List集合转为JSON数据并返回
            String result = JSON.toJSONString(courseList,filter);

            response.getWriter().print(result);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```

### 3.2.5 接口测试

使用postman进行多条件查询课程信息的功能接口测试

# 4. 接口3：新建课程营销信息

## 4.1 需求分析

1）选择新建课程，就会跳到营销信息页面。**就是在配置课程的营销信息，对课程营销信息进行录入，就是一个插入操作**，**新增课程的操作**

## 4.1.1 基本信息

需要的字段有：

* course_name      课程名称
* brief                      简介
* teacher_name      讲师名称
* teacher_info         讲师介绍
* preview_first_field         课程概述
* preview_second_field        

## 4.1.2 销售信息

需要的字段有：

* discounts        售卖价格 
* price                 原价
* price_tag         活动文案

## 4.1.3 分享信息

还有上传图片操作		**图片地址URL**

需要的字段有：

* share_image_title        图片标题              
* share_title                     标题
* share_description         简介

## 4.1.4 课程详情

字段：            **课程状态，创建时间和修改时间**

course_description           	 课程详细信息

## 4.2 Dao层编写

在CourseDao里添加一个**courseSalesInfo方法**

```java
接口
	// 保存课程营销信息
    public int courseSalesInfo(Course course);
实现类
    // 保存课程营销信息
    @Override
    public int courseSalesInfo(Course course) {

        try {
            // 1.创建QueryRunner
            QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

            // 2.编写SQL
            String sql = "INSERT INTO course(\n" +
                    "course_name,\n" +
                    "brief,\n" +
                    "teacher_name,\n" +
                    "teacher_info,\n" +
                    "preview_first_field,\n" +
                    "preview_second_field,\n" +
                    "discounts,\n" +
                    "price,\n" +
                    "price_tag,\n" +
                    "share_image_title,\n" +
                    "share_title,\n" +
                    "share_description,\n" +
                    "course_description,\n" +
                    "course_img_url,\n" +
                    "STATUS,\n" +
                    "create_time,\n" +
                    "update_time\n" +
                    ") VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

            // 3.准备参数
            Object[]  param = {course.getCourse_name(),course.getBrief(),course.getTeacher_name(),course.getTeacher_info(),
            course.getPreview_first_field(),course.getPreview_second_field(),course.getDiscounts(),course.getPrice(),
            course.getPrice_tag(),course.getShare_image_title(),course.getShare_title(),course.getShare_description(),
            course.getCourse_description(),course.getCourse_img_url(),course.getStatus(),course.getCreate_time(),course.getUpdate_time()};
            // 4.执行插入操作

            int row = qr.update(sql, param);
            return row;
        } catch (SQLException e) {
            e.printStackTrace();
            return 0;
        }
    }
```

## 4.3 Dao层的方法测试

```java
/**
     * course_name,
     * brief,
     * teacher_name,
     * teacher_info,
     * preview_first_field,
     * preview_second_field,
     * discounts,
     * price,
     * price_tag,
     * share_image_title,
     * share_title,
     * share_description,
     * course_description,
     *
     * 自己补全的字段：
     * course_img_url,
     * STATUS,
     * create_time,
     * update_time
     */
    // 测试保存课程营销信息
    @Test
    public void testCourseSalesInfo(){

        // 1.创建一个Course对象，作为保存操作的对象
        Course course = new Course();
        course.setCourse_name("本草纲目");
        course.setBrief("如果华佗在世");
        course.setTeacher_name("周杰伦");
        course.setTeacher_info("亚洲天王");
        course.setPreview_first_field("共4讲");
        course.setPreview_second_field("每周五更新");
        course.setDiscounts(88.22);
        course.setPrice(188.0);
        course.setPrice_tag("最新优惠价");
        course.setShare_image_title("哈哈");
        course.setShare_title("嘻嘻");
        course.setShare_description("如果华佗在世，崇洋都被医治");
        course.setCourse_description("我表情悠哉，跳个大概");
        course.setCourse_img_url("https://www.xx.com/xxx.jpg");
        course.setStatus(1);  // 1 上架  0 下架
        String dateFormart = DateUtils.getDateFormart();
        course.setCreate_time(dateFormart);
        course.setUpdate_time(dateFormart);

        int i = courseDao.courseSalesInfo(course);
        System.out.println(i);

    }
```

## 4.4 Service层编写

1.**因为在项目中，会进行很多插入修改的操作，最终DAO层会返回受影响的行数，我们都需要对状态进行判断，所以为了简化代码，把对DAO层返回的状态进行判断。把状态封装成枚举类**

编写枚举类，设置响应状态码 

```java
/**
 * 来表示DAO层返回的状态码信息的枚举类
 */
public enum StatusCode {

    // 定义两个实例
    // 通过有参构造给这两个枚举对象赋值
    // 成功 code 0 返回信息：保存成功
    // 失败 code 1 返回信息：
    SUCCESS(0,"success"),FAIL(1,"fail");

    // 定义属性
    private int code;   // 表示状态
    private String message;  // 表示状态信息

    StatusCode() {
    }

    StatusCode(int code, String message) {
        this.code = code;
        this.message = message;
    }

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    // 因为根据接口文档定义看到后台响应结果是JSON类型的，所以要将枚举对象转为JSON
    // 重写toString方法，将枚举对象转为JSON
    // 哪个枚举类对象调用toString，就返回拼接好的JSON数据
    @Override
    public String toString() {
        JSONObject object = new JSONObject();
        object.put("status",code);
        object.put("msg",message);

        return object.toString();
    }
}
```

2.编写Service层

在CourseService层添加**courseSalesInfo方法**

```java
接口
// 保存课程营销信息
    // 在DAO层会返回一个受影响的行数，在Service层进行判断，如果大于0插入成功，返回成功的字符串
    public String courseSalesInfo(Course course);
实现类
    // 保存课程营销信息
    @Override
    public String courseSalesInfo(Course course) {

        // 1.补全课程营销信息
        // 因为在前台页面中传入的参数不够，需要补齐参数，创建时间，修改时间和状态
        // 因为在第一次新增课程营销信息时，创建时间和修改时间是一致的
        // 等到前台页面需要对课程营销信息进行修改时，再重新设定update_time
        String strDate = DateUtils.getDateFormart();
        course.setCreate_time(strDate);
        course.setUpdate_time(strDate);
        course.setStatus(1);    // 1 表示上架

        // 2.执行插入操作，返回受影响的行数，如果大于0表示插入成功，否则插入失败
        int row = courseDao.courseSalesInfo(course);

        // 3.判断
        if (row>0) {
            // 插入成功
            String result = StatusCode.SUCCESS.toString();
            return result;
        } else {
            // 如果插入失败
            String result = StatusCode.FAIL.toString();
            return result;
        }
    }
```

## 4.5 文件上传

### 4.5.1 图片上传分析

在需求文档中，当去添加课程的营销信息时，有文件上传的操作

### 4.5.2 文件上传介绍

文件上传的本质：就是文件的拷贝

* 文件上传：从本地将文件拷贝到服务器上
  * 客户端：需要编写文件上传表单
  * 服务端：需要编写代码接收上传的文件

### 4.5.3 客户端编码

1）文件上传三要素：

1. 通过form表单对内容进行提交，提交方式：**post**（get方式提交有大小限制）
2. 表单的enctype属性：必须设置为：**multipart/form-data**
   1. enctype就是编码类型
   2. **multipart/form-data表示多部件上传，指表单有多部分构成，既有文本，又有文件**
3. 表单必须有文件上传项：input框的type为**file**，input框要有**name属性和值**，后台获取属性值

2）根据客户端三要素的代码示列：

```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <%-- 文件上传的三要素
            1. 表单提交方式必须为post
            2. 表单的 enctype 属性必须为：multipart/from-data
            3. 表单中必须有文件上传项
     --%>
    <form method="post" enctype="multipart/form-data" action="${pageContext.request.contextPath}/upload">
        <input type="file" name="upload"/>
        <br/>
        <input type="text" name="name"/>
        <br/>
        <input type="text" name="password"/>

        <input type="submit" value="文件上传"/>
    </form>
</body>
</html>
```



### 4.5.4 服务端编码

服务端要接收文件上传的表单数据

#### 通过抓包分析请求体中的内容

文件上传的原理：

如果表单是multipart/form-data类型上传的数据**在请求体中被分隔成了三部分**

#### 服务端获上传文件的步骤：

1. 通过request获取请求体中的内容
2. 解析请求体 多部件上传的特点是，每个input都是一个表单项
   1. 根据分隔符将请求中所有的内容，切割成数组，数组中的每一个元素 都是一个表单项
3. 遍历数组，分清哪个是普通的表单项，哪个是文件上传项
   1. 如何区分？判断是否有 filename
4. 获取到普通表单项中的内容，通过属性name获取
5. 获取文件上传项
   1. 文件名：filename=aaa.txt
   2. 文件内容：
6. 使用IO将文件内容，保存到服务器中

### 4.5.5 FileUpload工具类

#### 1.导入依赖

使用这个工具类可以很容易的将文件上传到web服务器

IOUtils对Java中的io进行了封装

#### 2.FileUpload 核心类介绍

* DiskFileItemFactory             工厂类
* ServletFileUpload                  文件上传的核心类，通过该类解析request，获取FileItem
* FileItem                                     代表每一个表单项

#### 3. 文件上传的API的详解

* ServletFileUpload

| 方法                         | 说明                         |
| ---------------------------- | ---------------------------- |
| isMultipartContent(request); | 判断是否是一个文件上传的表单 |
| parseRequest(request);       | 解析request获得表单项的集合  |
| setHeaderEncoding("UTF-8");  | 设置上传的文件名的编码方式   |

* FileItem

| 方法             | 说明                 |
| ---------------- | -------------------- |
| isFormField()    | 判断是否是普通表单项 |
| getFieldName()   | 获得表单的name属性值 |
| item.getString() | 获得表单的value值    |
| getName()        | 获得上传文件的名称   |
| getInputStream() | 获得上传文件         |
| delete()         | 删除临时文件         |

#### 4. 文件上传后台代码的编写

FileUpload完成文件上传操作的步骤：

1. 创建磁盘文件工厂
2. 创建文件上传的核心类
3. 解析request--获得表单项集合
4. 遍历表单项集合
5. 判断普通表单项/文件上传项

```java
@WebServlet("/upload")
public class FileUploadServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        try {
            // 使用FileUpload完成文件上传操作
            // 1.创建磁盘文件工厂对象
            DiskFileItemFactory factory = new DiskFileItemFactory();

            // 2.创建文件上传的核心类
            ServletFileUpload upload = new ServletFileUpload(factory);
            // 2.1 设置上传文件的编码 防止文件中文乱码
            upload.setHeaderEncoding("utf-8");
            // 2.2 判断表单是否 是文件上传表单
            boolean multipartContent = ServletFileUpload.isMultipartContent(req);
            // 2.3 是文件上传表单
            if (multipartContent) {
               // 3.解析request -- 获取表单项的集合
                List<FileItem> list = upload.parseRequest(req);
                // 4.遍历表单项的集合
                if (list != null) {
                    // 遍历集合 获取表单项
                    for (FileItem item : list) {
                // 5.判断是普通的表单项还是 文件上传项
                        boolean formField = item.isFormField();
                        if (formField) {
                            // 普通表单项
                            // 获取到属性名
                            String fieldName = item.getFieldName();
                            String fieldValue = item.getString("utf-8"); // 设置编码

                            System.out.println(fieldName + "=" + fieldValue);
                        }else {
                            // 文件上传项
                            // 获取文件名
                            String fileName = item.getName();

                            // 拼接新的文件名 使用UUID保证不重复
                           String newFileName = UUIDUtils.getUUID() + "_" + fileName;

                           // 获取输入流  指向了文件
                            InputStream inputStream = item.getInputStream();

                            // 创建输出流
                            FileOutputStream outputStream = new FileOutputStream("F:/upload/" + newFileName);

                            // 使用IOUtils工具类 完成文件的拷贝
                            IOUtils.copy(inputStream,outputStream);

                            // 关闭流
                            outputStream.close();
                            inputStream.close();
                        }
                    }
                }
            }
        } catch (FileUploadException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```



### 4.5.6 将图片上传到Tomcat服务器中

#### 1.将项目部署到webapps

把图片放到硬盘上，不方便访问，所以要把图片上传到Tomcat服务器中，这样可以通过外部加载图片

##### 将部署方式改变为war模式，把项目部署在Tomcat的webapps下

* idea中部署项目两种方式
  * war模式下：项目会被部署到Tomcat的webapps目录下
  * war exploded模式：idea的映射模式，部署在maven项目的target目录中

#### 2.在webapps中创建upload目录

upload文件夹专门用来保存上传的图片

#### 3.修改代码，将图片上传到服务器的webapps的upload目录下

* 修改图片的输出路径
  * 获取到项目的运行目录信息
  * 截取到webapps的目录路径
  * 拼接输出路径，将图片保存到upload文件夹里

```java
@WebServlet("/upload")
public class FileUploadServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        try {
            // 使用FileUpload完成文件上传操作
            // 1.创建磁盘文件工厂对象
            DiskFileItemFactory factory = new DiskFileItemFactory();

            // 2.创建文件上传的核心类
            ServletFileUpload upload = new ServletFileUpload(factory);
            // 2.1 设置上传文件的编码 防止文件中文乱码
            upload.setHeaderEncoding("utf-8");
            // 2.2 判断表单是否 是文件上传表单
            boolean multipartContent = ServletFileUpload.isMultipartContent(req);
            // 2.3 是文件上传表单
            if (multipartContent) {
               // 3.解析request -- 获取表单项的集合
                List<FileItem> list = upload.parseRequest(req);
                // 4.遍历表单项的集合
                if (list != null) {
                    // 遍历集合 获取表单项
                    for (FileItem item : list) {
                // 5.判断是普通的表单项还是 文件上传项
                        boolean formField = item.isFormField();
                        if (formField) {
                            // 普通表单项
                            // 获取到属性名
                            String fieldName = item.getFieldName();
                            String fieldValue = item.getString("utf-8"); // 设置编码

                            System.out.println(fieldName + "=" + fieldValue);
                        }else {
                            // 文件上传项
                            // 获取文件名
                            String fileName = item.getName();

                            // 拼接新的文件名 使用UUID保证不重复
                           String newFileName = UUIDUtils.getUUID() + "_" + fileName;

                           // 获取输入流  指向了文件
                            InputStream inputStream = item.getInputStream();

                            // 创建输出流
                            // 要输出的图片位置不是硬盘的位置了，要放到Tomcat服务器上，webapps下的upload文件夹
                            // 1.获取项目的运行目录
                            // 获取到的路径：// F:\software\apache-tomcat-8.5.55\webapps\lagou_edu_home\
                            String realPath = this.getServletContext().getRealPath("/");

                            // 截取到F:\software\apache-tomcat-8.5.55\webapps\路径
                            // 2.截取到 webapps目录的路径
                            String webappsPath = realPath.substring(0, realPath.indexOf("lagou_edu_home"));

                            // 3.拼接输出路径，将图片保存到 upload
                            FileOutputStream outputStream = new FileOutputStream(webappsPath + "/upload/" + newFileName);
                            
                            // 使用IOUtils工具类 完成文件的拷贝
                            IOUtils.copy(inputStream,outputStream);

                            // 关闭流
                            outputStream.close();
                            inputStream.close();
                        }
                    }
                }
            }
        } catch (FileUploadException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```



#### 4.页面加载图片

**将Tomcat作为图片服务器使用时，存储上传的图片后，如果想要图片可以访问，需要在idea中进行配置：**

1）在Tomcat，Deployment里，选择external source ---> 找到webapps目录下的的upload文件夹

2）上传一张图片到服务器

3）在项目内部页面加载图片    静态资源

```
<img src="/upload/abbd99891af442a8a9cb65848744452e_qiyu.jpg">
```

4) 也可以通过HTTP方式也可以访问图片

```
http://localhost:8080/upload/abbd99891af442a8a9cb65848744452e_qiyu.jpg
```

##### 这时Tomcat就兼具了web项目服务器和图片服务器的两个作用

## 4.6 BeanUtils工具类

1）介绍

主要用于简化JavaBean封装数据的操作。**可以将一个表单提交的所有数据封装到对应JavaBean中**

可以获取表单提交的内容直接封装到JavaBean中

2）引入依赖

3）BeanUtils常用方法

| 方法                                             | 描述                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| populate(Object bean, Map properties)            | 将Map数据封装到指定Javabean中<br/>一般用于将表单的所有数据封装到javabean |
| setProperty(Object obj,String name,Object value) | 设置属性值                                                   |
| getProperty(Object obj,String name)              | 获得属性值                                                   |

4）BeanUtils 使用测试

```
如果想使用BeanUtils直接封装，就一定要让map中的key要与course的属性名保持一致，value的数据类型与course的属性的类型保持一致
```

```java
@Test
    public void test01() throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {

        // 1.创建Course对象
        Course course = new Course();

        // 2.创建Map
        Map<String,Object> map = new HashMap<>();

        // 3.向map集合中添加数据，key要与course的属性名保持一致，value的数据类型与course的属性的类型保持一致
        map.put("id",1);
        map.put("course_name","音乐课");
        map.put("brief","课程包含很多流行音乐");
        map.put("teacher_name","周杰伦");
        map.put("teacher_info","亚洲天王");

        // 使用BeanUtils将map中的数据封装到 course中
        BeanUtils.populate(course,map);

        System.out.println(course.getId() + " " + course.getCourse_name() + " " + course.getBrief() + " " + course.getTeacher_name()
        + " " + course.getTeacher_info());

        // 设置属性 获取属性
        BeanUtils.setProperty(course,"price",100.0);

        String price = BeanUtils.getProperty(course, "price");

        System.out.println(price);
    }
```



## 4.7 Servlet编写

### 4.7.1 CourseSalesInfoServlet

创建CourseSalesInfoServlet类，继承HttpServlet，完成保存课程营销信息操作

**因为页面上传的信息包含文件信息，类型是多部件，无法直接通过request直接获取参数，所以不能继承BaseServlet**

```java
/**
 * 保存和修改课程的营销信息
 */
@WebServlet("/courseSalesInfo")
public class CourseSalesInfoServlet extends HttpServlet {

    /**
     * 保存课程营销信息
     *      收集表单的数据，封装到course对象中，将图片上传到Tomcat服务器中
     */
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        try {
            // 1.创建Course对象     使用BeanUtils将数据封装到Course对象中
            Course course = new Course();

            // 2.创建Map集合，用来收集数据
            Map<String,Object> map = new HashMap<>();

            // 3.通过FileUpload进行文件上传操作
            // 创建磁盘工厂对象
            DiskFileItemFactory factory = new DiskFileItemFactory();

            // 4.创建文件上传核心对象
            ServletFileUpload fileUpload = new ServletFileUpload(factory);

            // 5.解析request对象，获取表单项集合
            List<FileItem> list = fileUpload.parseRequest(req);

            // 6.遍历集合，判断哪些是普通的表单项，哪些是文件表单项
            for (FileItem item : list) {

                boolean formField = item.isFormField();
                if (formField) {
                    // 是普通表单项，获取表单项中的数据，保存到map里
                    String fieldName = item.getFieldName();
                    String value = item.getString("utf-8");

                    // 使用map收集数据
                    map.put(fieldName,value);
                } else {
                    // 文件上传项
                    // 获取文件名
                    String fileName = item.getName();
                    // 避免重复，通过UUID作拼接成新的文件名
                    String newFileName = UUIDUtils.getUUID() + "_" + fileName;

                    // 获取输入流，指向文件
                    InputStream inputStream = item.getInputStream();

                    // 获取当前项目部署的路径
                    String realPath = this.getServletContext().getRealPath("/");

                    // 做切割，获取webapps的目录路径
                    String webappsPath = realPath.substring(0, realPath.indexOf("lagou_edu_home"));

                    // 创建输出流
                    OutputStream outputStream = new FileOutputStream(webappsPath + "/upload/" + newFileName);

                    // 作文件拷贝
                    IOUtils.copy(inputStream,outputStream);

                    // 关闭流
                    outputStream.close();
                    inputStream.close();

                    // 将图片路径进行保存
                    map.put("course_img_url", Constants.LOCAL_URL + "/upload/" + newFileName);
                }
            }

            // 使用BeanUtils 将map中的数据封装到course对象
            BeanUtils.populate(course,map);

            // 补全信息
            course.setStatus(1);    // 上架
            String dateFormart = DateUtils.getDateFormart();
            course.setCreate_time(dateFormart); // 创建时间
            course.setUpdate_time(dateFormart); // 修改时间

            // 业务处理
            CourseService courseService = new CourseServiceImpl();
            String result = courseService.courseSalesInfo(course);

            // 响应结果
            resp.getWriter().print(result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

### 4.7.2 接口测试

postman测试上传文件       **模拟在页面上填数据，保存**

1. 接口地址填写正确
2. **将请求方式设置为POST**
3. 需要上传文件，设置Headers为：**"key":"Content-Type", "value":"multipart/form-data"**
4. **Body选择form-data**
5. key右侧下拉选择file，value点击Select Files选择文件 , 按照接口文档,在body补全测试参数

### 4.7.3 保存图片URL优化

拼接上Tomcat访问路径，可以直接访问图片

1. 创建常量类

```java
public final class Constants {

    //本地访问地址
    public static final String LOCAL_URL = "http://localhost:8080";
}
```

2. 拼接图片URL

```java
//将图片路径进行保存
 map.put("course_img_url", Constants.LOCAL_URL+"/upload/" + newFileName);
```



# 5. 接口4：修改课程营销信息的功能

## 5.1 需求分析

营销信息其实就是课程相关的信息，操作的依然是course表，我们通过点击营销信息按钮，进入到对应的课程营销信息页面，对原有信息进行修改

* 当我们选择某个课程时，点击营销信息
* 就会跳转到对应的课程的营销信息修改页面
* 在点击营销信息的按钮后，**要传递课程id给到Servlet**
* **Servlet根据课程id进行查询，将查询结果返回给前台进行回显**
* 进行数据的回显，修改操作。修改完成，点击保存
* 再次发送请求到修改操作的Servlet，将修改后的数据进行保存

## 5.2 DAO层编写

1）通过上面的分析，当点击营销信息时，根据当前课程id，查询出课程信息进行回显。所以要写一个根据id进行查询的功能

在CourseDao里添加一个**findCourseById方法**

```java
接口
    // 根据ID获取课程营销信息
    public Course findCourseById(Int id);
实现类
	// 根据ID获取课程营销信息
    @Override
    public Course findCourseById(int id) {

        try {
            QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

            String sql = "SELECT \n" +
                    "id,\n" +
                    "course_name,\n" +
                    "brief,\n" +
                    "teacher_name,\n" +
                    "teacher_info,\n" +
                    "preview_first_field,\n" +
                    "preview_second_field,\n" +
                    "discounts,\n" +
                    "price,\n" +
                    "price_tag,\n" +
                    "share_image_title,\n" +
                    "share_title,\n" +
                    "share_description,\n" +
                    "course_description,\n" +
                    "course_img_url,\n" +
                    "STATUS\n" +
                    "FROM course WHERE id = ?";

            Course course = qr.query(sql, new BeanHandler<Course>(Course.class), 64);
            return course;

        } catch (SQLException e) {
            e.printStackTrace();
            // 出现异常返回null
            return null;
        }
    }
```

2）编写修改课程营销信息的方法，将修改写入数据库

一旦把数据进行了回显，用户就可以对页面数据进行修改，修改后点击保存，进行修改操作

在CourseDao里添加一个**updateCourseSalesInfo方法**

```java
接口
	// 修改课程营销信息
    public int updateCourseSalesInfo(Course course);
实现类
	// 修改课程营销信息
    @Override
    public int updateCourseSalesInfo(Course course) {

        try {
            QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

            String sql = "UPDATE course SET \n" +
                    "course_name = ?,\n" +
                    "brief = ?,\n" +
                    "teacher_name = ?,\n" +
                    "teacher_info = ?,\n" +
                    "preview_first_field = ?,\n" +
                    "preview_second_field = ?,\n" +
                    "discounts = ?,\n" +
                    "price = ?,\n" +
                    "price_tag = ?,\n" +
                    "share_image_title = ?,\n" +
                    "share_title = ?,\n" +
                    "share_description = ?,\n" +
                    "course_description = ?,\n" +
                    "course_img_url = ?,\n" +
                    "update_time = ? \n" +
                    "WHERE id = ?";

            Object[] param = {course.getCourse_name(),course.getBrief(),course.getTeacher_name(),course.getTeacher_info(),
            course.getPreview_first_field(),course.getPreview_second_field(),course.getDiscounts(),course.getPrice(),
            course.getPrice_tag(),course.getShare_image_title(),course.getShare_title(),course.getShare_description(),
            course.getCourse_description(),course.getCourse_img_url(), course.getUpdate_time(),course.getId()};

            int  row = qr.update(sql, param);
            return row;
        } catch (SQLException e) {
            e.printStackTrace();
            // 出现异常返回0
            return 0;
        }
    }
```

3)测试

## 5.3 Service层编写

在CourseService里添加一个**findCourseById**根据id查询营销信息的方法和**updateCourseSalesInfo**修改营销信息的方法

```java
接口
// 根据id进行查询课程营销信息
    public Course findCourseById(int id);
实现类
    // 根据id 进行课程信息查询
    @Override
    public Course findCourseById(int id) {

       return courseDao.findCourseById(id);
    }
```

```java
接口
    // 修改课程营销信息
    public String updateCourseSalesInfo(Course course);
实现类
    // 修改课程信息
    @Override
    public String updateCourseSalesInfo(Course course) {

        int row = courseDao.updateCourseSalesInfo(course);

        // 判断是否保存成功
        if (row>0) {
            // 保存成功
            String result = StatusCode.SUCCESS.toString();
            return result;
        } else {
            // 保存失败
            String result = StatusCode.FAIL.toString();
            return result;
        }
    }
```

## 5.4 Servlet编写				

## JSON在转换时空值不会转换，但是整型的默认值的数据会转换，所以使用SimplePropertyPreFilter进行对指定JSON数据的转换

### 5.4.1 根据ID查询课程信息

#### 5.4.1.1 CourseServlet

在CourseServlet里添加一个**findCourseById方法**

```java
// 根据课程id 查询课程信息
    public void findCourseById(HttpServletRequest request, HttpServletResponse response){

        try {
            // 1.接收参数，methodName已在BaseServlet接收
            String id = request.getParameter("id");

            // 2.业务处理
            CourseService courseService = new CourseServiceImpl();
            Course course = courseService.findCourseById(Integer.parseInt(id));

            // 3.返回结果，JSON数据格式的
            // 指定转换的JSON数据
            SimplePropertyPreFilter filter = new SimplePropertyPreFilter(Course.class,"id",
                    "course_name","brief","teacher_name","teacher_info","price","price_tag","discounts",
                    "preview_first_field","preview_second_field","course_img_url","share_title","share_description",
                    "course_description","share_image_title");

            String jsonString = JSON.toJSONString(course,filter);
            response.getWriter().print(jsonString);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```

#### 5.4.1.2 接口测试

在postman中测试

### 5.4.2 修改CourseSalesInfoServlet

#### 5.4.2.1 需求分析

保存营销信息和修改营销信息,访问的是同一个接口,所以在**CourseSalesInfoServlet**中,我们需要进行一下判断

* 携带id 就是修改操作
* 未携带id就是新增操作

#### 5.4.2.2 代码修改

```java
/**
 * 保存和修改课程的营销信息
 */
@WebServlet("/courseSalesInfo")
public class CourseSalesInfoServlet extends HttpServlet {

    /**
     * 保存课程营销信息
     *      收集表单的数据，封装到course对象中，将图片上传到Tomcat服务器中
     */
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        try {
            // 1.创建Course对象     使用BeanUtils将数据封装到Course对象中
            Course course = new Course();

            // 2.创建Map集合，用来收集数据
            Map<String,Object> map = new HashMap<>();

            // 3.通过FileUpload进行文件上传操作
            // 创建磁盘工厂对象
            DiskFileItemFactory factory = new DiskFileItemFactory();

            // 4.创建文件上传核心对象
            ServletFileUpload fileUpload = new ServletFileUpload(factory);

            // 5.解析request对象，获取表单项集合
            List<FileItem> list = fileUpload.parseRequest(req);

            // 6.遍历集合，判断哪些是普通的表单项，哪些是文件表单项
            for (FileItem item : list) {

                boolean formField = item.isFormField();
                if (formField) {
                    // 是普通表单项，获取表单项中的数据，保存到map里
                    String fieldName = item.getFieldName();
                    String value = item.getString("utf-8");

                    // 使用map收集数据
                    map.put(fieldName,value);
                } else {
                    // 文件上传项
                    // 获取文件名
                    String fileName = item.getName();
                    // 避免重复，通过UUID作拼接成新的文件名
                    String newFileName = UUIDUtils.getUUID() + "_" + fileName;

                    // 获取输入流，指向文件
                    InputStream inputStream = item.getInputStream();

                    // 获取当前项目部署的路径
                    String realPath = this.getServletContext().getRealPath("/");

                    // 做切割，获取webapps的目录路径
                    String webappsPath = realPath.substring(0, realPath.indexOf("lagou_edu_home"));

                    // 创建输出流
                    OutputStream outputStream = new FileOutputStream(webappsPath + "/upload/" + newFileName);

                    // 作文件拷贝
                    IOUtils.copy(inputStream,outputStream);

                    // 关闭流
                    outputStream.close();
                    inputStream.close();

                    // 将图片路径进行保存
                    map.put("course_img_url", Constants.LOCAL_URL + "/upload/" + newFileName);
                }
            }

            // 使用BeanUtils 将map中的数据封装到course对象
            BeanUtils.populate(course,map);

            String dateFormart = DateUtils.getDateFormart();

            // 业务处理
            CourseService courseService = new CourseServiceImpl();

            // 判断是否为修改操作，若id不为空，就证明携带了id，是修改操作，否则就是新增操作
            if (map.get("id") != null) {
                // 修改操作
                // 补全信息
                course.setUpdate_time(dateFormart);
                String result = courseService.updateCourseSalesInfo(course);

                // 响应结果
                resp.getWriter().print(result);

            } else {
                // 新建操作
                // 补全信息
                course.setStatus(1);    // 上架
                course.setCreate_time(dateFormart); // 创建时间
                course.setUpdate_time(dateFormart); // 修改时间


                String result = courseService.courseSalesInfo(course);

                // 响应结果
                resp.getWriter().print(result);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

#### 5.4.2.3 接口测试

根据接口文档，进行postman测试

# 6. 接口5：修改课程状态

## 6.1 需求分析

1）数据库中课程状态码为0或者1，课程状态status，0代表下架，1上架。修改课程状态就是对status字段进行操作

2）页面分析

页面会显示当前课程的状态，点击上架修改状态为上架

## 6.2 DAO层编写

在CourseDao中添加一个**updateCourseStatus**修改课程状态方法

```java
接口
	// 修改课程状态
    public int updateCourseStatus(Course course);
实现类
	// 修改课程状态
    @Override
    public int updateCourseStatus(Course course) {

        try {
            QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());

            String sql = "UPDATE course SET STATUS = ? ,update_time = ? WHERE id = ?";

            Object[] param = {course.getStatus(),course.getUpdate_time(),course.getId()};

            int row = qr.update(sql, param);
            return row;
        } catch (SQLException e) {
            e.printStackTrace();
            // 执行失败返回0
            return 0;
        }
    }
```

## 6.3 Service层编写

在CourseService中添加一个**updateCourseStatus**修改课程状态方法

在接口文档中的响应结果为status，对应的是修改后的状态，需要给前台返回key value格式  0 下架，1 上架

在Service层就把响应的数据封装好，因为在Service层判断，修改成功根据状态作判断，把数据返回

```java
接口
    // 修改课程状态
    // 返回的数据是key value格式的，所以定义返回值为map
    public Map<String,Integer> updateCourseStatus(Course course);
实现类
    // 修改课程状态
    @Override
    public Map<String, Integer> updateCourseStatus(Course course) {

        // 调用dao，返回受影响的行数
        int row = courseDao.updateCourseStatus(course);

        Map<String,Integer> map = new HashMap<>();
        // 判断是否插入成功

        if (row>0) {
            // 进行数据封装
            // 判断修改后的课程状态
            if(course.getStatus() == 0){
                map.put("status",0);
            } else {
                map.put("status",1);
            }
        }
        return map;
    }
```

## 6.4 Servlet编写     修改课程状态的接口

在CourseServlet中, 添加**updateCourseStatus**方法

```java
// 修改课程状态
    /**
     * 因为前台传过来的只有id，所以要根据id先把课程信息查出来
     * 然后再对课程状态进行判断，进行取反设置，只要访问到了这个修改课程状态的接口，就是修改课程状态的，所以设置status状态
     * 如果为1，设置0，如果为0，设置1
     * @param request
     * @param response
     */
    public void updateCourseStatus(HttpServletRequest request, HttpServletResponse response){

        try {
            // 1.获取参数
            String id = request.getParameter("id");

            // 2.业务处理，调用Service层的方法
            CourseService courseService = new CourseServiceImpl();

            // 3.根据课程id 查询课程信息
            Course course = courseService.findCourseById(Integer.parseInt(id));

            // 4.判断课程信息状态，进行取反设置
            int status = course.getStatus();

            // 访问到这个修改状态的接口，就意味着要修改状态，所以要判断状态进行修改
            if (status == 0) {
                // 如果是0，设置为1
                course.setStatus(1);
            } else {
                // 如果是1，设置为0
                course.setStatus(0);
            }

            // 5.设置更新时间
            course.setUpdate_time(DateUtils.getDateFormart());

            // 6.调用Service层的修改状态方法,返回修改后的课程状态的信息
            Map<String, Integer> map = courseService.updateCourseStatus(course);

            // 7.响应结果
            String jsonString = JSON.toJSONString(map);
            response.getWriter().print(jsonString);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```

## 6.5 接口测试

根据接口文档，进行postman测试